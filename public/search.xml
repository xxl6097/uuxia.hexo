<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android导入第三方静态库.a编译成动态库.so]]></title>
    <url>%2F2016%2F05%2F11%2Fandroid-ndk-so-a%2F</url>
    <content type="text"><![CDATA[Android导入第三方静态库.a编译成动态库.so 下面我以一个简单的实际例子来讲解如何在动态库中导入静态库。 静态库中的源代码有两个文件：static.h, static.c，有一个add方法 static.h12345678#include &lt;stdio.h&gt; int add(int x, int y);static.c#include &quot;static.h&quot; int add(int x, int y) &#123; return x + y; &#125; 将它编译成静态库，Android.mk如下： 12345LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := static_add LOCAL_SRC_FILES := static.c include $(BUILD_STATIC_LIBRARY) 注意编译静态库的时候，必须有一个Application.mk文件： APP_MODULES:=static_add APP_MODULES的值应该和Android.mk中的LOCAL_MODULE的值保持一样。 然后调用ndk-build进行编译生成libstatic_add.a静态库 123456789101112hejinlai_iMac:jni hejinlai$ ndk-buildPrebuilt : libstatic_add.a &lt;= jni/ 生成静态库后，然后编写动态库中的源代码: share.h share.c share.h [cpp]#include int test_add(int x, int y);share.c1234567 #include “share.h”#include “static.h”int test_add(int x, int y)&#123;// 调用static里面的方法return add(x, y);&#125; 编写导入静态库的Android.mk：12345678910LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := static_add LOCAL_SRC_FILES := libstatic_add.a include $(PREBUILT_STATIC_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := share_add LOCAL_STATIC_LIBRARIES := static_add LOCAL_SRC_FILES := share.c include $(BUILD_SHARED_LIBRARY) 注意上面生成的libstatic_add.a必须跟Android.mk放在同一目录下，否则需要填写相应的路径，然后进行编译：12hejinlai_iMac:jni hejinlai$ ndk-buildCompile thumb : share_add &lt;= share.c Prebuilt : libstatic_add.a &lt;= jni/ SharedLibrary : libshare_add.so Install : libshare_add.so =&gt; libs/armeabi/libshare_add.so 提示so编译成功。 需要注意的是我这边share.c和static.c放在同一目录下，如果放在不同的目录下，需要指定 LOCAL_C_INCLUDES链接到相应的路径。]]></content>
      <categories>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>Andorid</tag>
        <tag>ndk</tag>
        <tag>so</tag>
        <tag>a</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜马拉雅WiFi音响绑定及通讯协议初稿]]></title>
    <url>%2F2016%2F05%2F11%2Fximalaya%2F</url>
    <content type="text"><![CDATA[喜马拉雅WiFi音响绑定及通讯协议初稿 通讯协议 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 1字节 2字节 1字节 1字节 8字节 6字节 4字节 8字节 2字节 N字节 2字节 通讯Json格式：{ &quot;cmd&quot;: 0 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 参数说明 参数名称 是否必须 字段类型 参数说明 cmd YES int 命令码 code NO int 返回码 msg NO String 状态消息 data NO String 数据节点 全局命令码 每一种操作对用一个命令码，用作标识指令。 全局命令码说明如下： 命令码（十六进制） 十进制 说明 0x0001 1 添加歌曲 0x0002 2 App查询歌曲列表 0x0003 3 升级操作 0x0004 4 播放 0x0005 5 关机 0x0006 6 静音/解除静音 0x0007 7 音量+ 0x0008 8 音量- 0x0009 9 切换aux状态 0x000a 10 下一曲 0x000b 11 上一曲 0x000c 12 暂停 0x000d 13 App查询播放状态 0x000e 14 WIFI 无线简易连接 0x000f 15 设备回复心跳 0x400f 16399 App发送心跳 0x0011 17 palyMode(顺序播放/随机播放/列表循环/单曲循环/) 0x0012 18 音量设置（直接设置音量值） 0x0013 19 设备推送播放状态 0x0014 20 设备推送播放列表 0x0015 21 拖拽进度条 全局返回码 每次调用接口时，可能获得正确或错误的返回码，可以根据返回码信息调试接口，排查错误。 ####全局返回码说明如下：|0| 请求成功||:—–|:—||200| 无错误||400 |不支持此接口||401 |JSON数据解析错误| 示例字符串{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: &quot;This is string&quot; //数据节点 } 整形参数{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: 1 //数据节点 } 对象{ &quot;cmd&quot;: 0x0001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;ssid&quot;:&quot;TP-link&quot;, //连接的路由名称 &quot;password&quot;:&quot;12345678&quot;, //路由密码,需要加密 } } 数组{ &quot;cmd&quot;: 0x001 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;:[ { &quot;id&quot; ： &quot;0&quot; &quot;name&quot; ： “xxxx&quot;, &quot;artist&quot; ： “xxxx&quot;, &quot;album_title&quot;： “xxxx&quot;, &quot;cover_url_small”：“xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxx&quot; {详细规格见规格说明url部分}, }, { &quot;id&quot;:&quot;1&quot; &quot;name&quot;:&quot;xxxx1&quot;, &quot;artist&quot;:&quot;xxxx1&quot;, &quot;album&quot;:&quot;xxxx1&quot;, &quot;cover_url_small&quot;:&quot;xxxx&quot;, &quot;cover_url_middle&quot;:&quot;xxxx&quot;, &quot;cover_url_large&quot;:&quot;xxxx&quot;, &quot;url&quot;:&quot;xxxxxxxxxx&quot;{详细规格见规格说明url部分}, } ] } 指令说明一、设备基础指令 App扫描设备|0x5A |数据长度 |框架版本 |协议类型 |设备编码 |Mac地址 |数据帧序列号 |保留字 |数据类型 |数据内容 |检验码FCS||:—-|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–||5A |0022| 40| 01| 0000000000000000| 000000000000| 20000000| 0000000000000000 |0405| data| 381a| 命令字：0x0405 data区：NULL 设备回复自身信息|0x5A |数据长度 |框架版本 |协议类型 |设备编码 |Mac地址 |数据帧序列号 |保留字 |数据类型 |数据内容 |检验码FCS||:—-|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–||5A |xxxx | 40| 01| 00000199001b0300 | d8f710e019b0 | 00000000| 0000000000000000 |0305 | data| xxxx| 命令字：0x0305 厂商ID：0x0199 大分类：0x1b 小分类：0x03 App发送心跳包|0x5A |数据长度 |框架版本 |协议类型 |设备编码 |Mac地址 |数据帧序列号 |保留字 |数据类型 |数据内容 |检验码FCS||:—-|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–||5A |xxxx | 40| 01| 0000000000000000| 000000000000| 20000000| 0000000000000000 |0104| data| xxxx| 命令字：0x0104 data区：json 示例： { &quot;cmd&quot;: 0x400f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 设备回复心跳|0x5A |数据长度 |框架版本 |协议类型 |设备编码 |Mac地址 |数据帧序列号 |保留字 |数据类型 |数据内容 |检验码FCS||:—-|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–|:—–||5A |xxxx | 40| 01| 0000000000000000| 000000000000| 00000000| 0000000000000000 |0204| data| xxxx| 命令字：0x0204 data区：json 示例： { &quot;cmd&quot;: 0x000f ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: { &quot;deviceId&quot;: &quot;SPK设备序列号&quot; } } 二、App主动控制终端指令1.App控制终端 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0104 data xxxx 命令字：0x0104 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 2.终端回复App 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0204 data xxxx 命令字：0x0204 data区：json数据 示例： { &quot;cmd&quot;: 0x00xx ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 三、终端主动发送控制数据给App1.周期上传运行数据 0x5A 数据长度 框架版本 协议类型 设备编码 Mac地址 数据帧序列号 保留字 数据类型 数据内容 检验码FCS 5A xxxx 40 01 0000000000000000 000000000000 00000000 0000000000000000 0105 data xxxx 命令字：0x0105 data区：json数据 示例： { &quot;cmd&quot;: 0x0013 ,//命令码 &quot;code&quot;: 0, //返回码 &quot;msg&quot;: &quot;&quot;, //状态消息 &quot;data&quot;: ...... //数据节点 } 音箱数据模型一、歌单参数说明 参数名称 是否必须 字段类型 参数说明 id 是 int 歌曲ID name 否 string 演唱者 artist 否 String 艺术家 album_title 否 String 专辑标题 lrc_id 否 String 歌词ID image_url_small 否 String 歌曲海报1 image_url_middle 否 String 歌曲海报2 image_url_large 否 String 歌曲海报3 mac 否 String Mac地址 total_time 否 int 歌曲时长 album_id 否 int 专辑ID utype 否 int 比如 虾米音乐 考虑 喜马拉雅 之类的 uri 是 int 歌曲URL downloadurl 是 String 下载url 二、播放状态参数说明|参数名称|是否必须 |字段类型|参数说明||:—-|:—–|:—–|:—–||id 是 |int| 歌曲ID||mtype |是 |String |虾米，百度云盘，本地音乐…||p_status| 否 |int |“0/1/2/3/4”, //准备播放，播放,暂停,停止,播放结束(用于网络收音机)||type| 否 |String| 当前播放源(预设preset),收藏,实时推送||name |否 |string |演唱者||artist |否 |String| 艺术家||album| 否 |String| 专辑||next_id| 是| int| 下一首歌曲id||total_time| 是| int| 歌曲总时间||current_time| 是| int| 歌曲当前播放时间||play_mode| 否| int| 模式（//顺序播放/随机播放列表循环/单曲循环/）||volume |是 |int| 音量| 绑定流程点击看大图 [原文链接地址]http://blog.csdn.net/xxl6097/article/details/50127949]]></content>
      <categories>
        <category>智能家居</category>
      </categories>
      <tags>
        <tag>Andorid</tag>
        <tag>智能家居</tag>
        <tag>喜马拉雅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绑定界面动资源画动态替换]]></title>
    <url>%2F2016%2F05%2F11%2Fpublic-bind%2F</url>
    <content type="text"><![CDATA[由于公共模块绑定满足不了TOB项目以及其他项目特殊需求，现对公共模块绑定界面的资源做成可配置，本文介绍一下哪些资源可配置以及如何配置。 颜色配置 颜色的配置需要在res/values，res/values-v14，res/values-v19，res/values-v21等目录下新建 color.xml。 color.xml内容如下： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;title_bar_bg_color&quot;&gt;#FFFF4444&lt;/color&gt;&lt;/resources&gt; 目录结构如图1所示 图1 1.标题颜1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;title_bar_bg_color&quot;&gt;填入需要配置的颜色值（#FFFF0000）&lt;/color&gt;&lt;/resources&gt; 2.子分类列表背景色1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;color_app_themes&quot;&gt;填入需要配置的颜色值（#FFFF0000）&lt;/color&gt;&lt;/resources&gt; 绑定动画配置 在主工程res/drawable下分别新建bind_scanning_anim.xml、bind_bouding_anim.xml、bind_failed_anim.xml、bind_sucess_anim.xml资源文件； 1.“扫描中“动画（bind_scanning_anim.xml），代码如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/scan1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/scan2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置中两帧，即：scan1.png和scan2.png 图片分辨率:201x307 2.绑定中 动画（bind_bouding_anim.xml），代码如下: 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/bouding1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding3&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding4&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/bouding5&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 绑定中 使用帧动画，默认配置使用5帧，即：bouding1.png、bouding2.png、bouding3.png、bouding4.png、bouding5.png 图片分辨率：392x276 3.失败 动画（bind_failed_anim.xml），代码如下： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/failed1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/failed2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置使用2帧，即：failed1.png和failed2.png 图片分辨率:203x306 4.成功 动画（bind_sucess_anim.xml），代码如下： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/sucess1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/sucess2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 扫描中 使用帧动画，默认配置使用2帧，即：sucess1.png和sucess2.png 图片分辨率:203x306 网络请求loadding图标配置在主工程res/drawable下分别新建bind_network_waiting.xml资源文件。代码如下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/load1&quot; android:duration=&quot;200&quot; /&gt; &lt;item android:drawable=&quot;@drawable/load2&quot; android:duration=&quot;200&quot; /&gt;&lt;/animation-list&gt; 网络请求loadding 使用帧动画，默认配置使用2帧，即：load1.png和load2.png 图片分辨率:126x126 缺省配置如图2： 图2 下拉列表Header动画配置在主工程res/drawable下分别新建bind_droplistview_anim.xml资源文件。代码如下：123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!-- 根标签为animation-list，其中oneshot代表着是否只展示一遍，设置为false会不停的循环播放动画 根标签下，通过item标签对动画中的每一个图片进行声明 android:duration 表示展示所用的该图片的时间长度 --&gt;&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/list1&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list2&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list3&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list4&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt; &lt;item android:drawable=&quot;@drawable/list5&quot; android:duration=&quot;150&quot;&gt;&lt;/item&gt;&lt;/animation-list&gt; 下拉列表Header动画 使用帧动画，默认配置使用5帧，即：list1.png、list2.png、list3.png、list4.png、list5.png 图片分辨率:72x72 缺省配置如图3： 图3]]></content>
      <categories>
        <category>智能家居</category>
      </categories>
      <tags>
        <tag>het</tag>
        <tag>智能家居</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下shadowsocks-libev一键安装脚本]]></title>
    <url>%2F2016%2F05%2F11%2Finstallshadowsocks%2F</url>
    <content type="text"><![CDATA[一键安装 libev 版的 shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。 系统要求系统支持：CentOS 32或64位内存要求：≥128M日期：2015年08月01日 本脚本适用环境：系统支持：CentOS 32或64位内存要求：≥128M日期：2015年08月01日 关于本脚本：一键安装 libev 版的 shadowsocks 最新版本。该版本的特点是内存占用小（600k左右），低 CPU 消耗，甚至可以安装在基于 OpenWRT 的路由器上。友情提示：如果你有问题，请先参考这篇《Shadowsocks Troubleshooting》后再问。 默认配置：服务器端口：自己设定（如不设定，默认为 8989）客户端端口：1080密码：自己设定（如不设定，默认为teddysun.com） 客户端下载：http://sourceforge.net/projects/shadowsocksgui/files/dist/ 使用方法：使用root用户登录，运行以下命令： 获取安装文件 1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-libev.sh 设置执行权限 1chmod +x shadowsocks-libev.sh 按照命令 1./shadowsocks-libev.sh 2&gt;&amp;1 | tee shadowsocks-libev.log 安装完成后，脚本提示如下： 12345678910Congratulations, shadowsocks-libev install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/357.htmlEnjoy it! 安装完成后即已后台启动 shadowsocks ，运行 1ps -ef | grep ss-server | grep -v ps | grep -v grep 使用命令 启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart查看状态：/etc/init.d/shadowsocks status 卸载方法 1./shadowsocks-libev.sh uninstall 更多版本 shadowsocks 安装 ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）Debian 下 Shadowsocks-libev 一键安装脚本Shadowsocks-go 一键安装脚本（CentOS，Debian，Ubuntu） 更新说明（2015 年 08 月 01 日）：1、新增自定义服务器端口功能（如不设定，默认为 8989）；更新说明（2015 年 04 月 30 日）：1、本脚本会始终安装最新版的 Shadowsocks；2、修改配置文件 /etc/shadowsocks-libev/config.json 同时启用 IPv4 与 IPv6 支持：123456789&#123; &quot;server&quot;:[&quot;[::0]&quot;,&quot;0.0.0.0&quot;], &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 3、Shadowsocks libev 版不能通过修改配置文件来多端口（只能开启多进程），如果你需要多端口请安装 Python 或 Go 版； 特别说明：1、已安装旧版本的 shadowsocks 需要升级的话，需下载本脚本的最新版，运行卸载命令 ./shadowsocks-libev.sh uninstall然后，再次执行本脚本即可安装最新版。 参考链接：https://github.com/madeye/shadowsocks-libev]]></content>
      <categories>
        <category>翻墙</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios开发笔记]]></title>
    <url>%2F2016%2F05%2F10%2Fiosdev%2F</url>
    <content type="text"><![CDATA[http://www.williamlong.info/archives/4319.html 证书知识及准备工作 几种开发者帐号区别 真机调试流程 内测发布流程 Appstore 上架流程 目录导航 证书知识及准备工作 基础问题答疑 什么是证书 什么时候需要证书 证书如何获得 如何对代码进行签名 我生成的私钥如何共享给团队成员 各流程中证书的需求情况 模拟器调试 真机调试 打包和发布 消息推送后端服务 开发中常见的证书及相关文件介绍 CSR(certificate request) 文件 开发者证书 apns(Apple Push Notification Service) 证书 p12(Personal Information Exchange) 证书 描述文件(Provisioning Profiles) 附录1: 开发准备相关的网址 几种开发者帐号区别 关键区别 真机调试流程 基本概念 条件和流程 内测发布流程 基本概念 实现条件 几种常见的分发途径 附录2: 常见分发渠道及工具地址 Appstore 上架流程 附录3: App store最新审核标准(2015.3) 证书知识及准备工作基础问题答疑什么是证书由 apple 官方颁发, 用以证明开发者身份的特殊文件, 在 iOS 开发中主要用于代码签名, 保障 iOS 生态的健康安全, 分为开发者证书和发布者证书 什么时候需要证书只有在本机模拟器调试时无需代码签名, 当 App 需要在真机运行和发布时需要使用相应证书进行签名 证书如何获得首先需要拥有相应权限的开发者帐号, 通过在本地生成配对的密钥, 向 provisioning portal 提交公钥后换取, 后续证书在使用时会验证本地私钥 如何对代码进行签名在 xcode 中, 使用描述文件(provision profile 包含调试者证书, 授权设备清单, 应用ID), 在 Build Settings 中选择存于 Keychain Access 中的证书文件设置调试和发布任务时的代码签名 我生成的私钥如何共享给团队成员在 Keychain Access 中找到导入的证书, 右击导出为包含私钥的 Personal Information Exchange(.p12)文件(导出时可以创建密码), 团队成员再导入 p12 证书后就完整包含了证书和私钥 各流程中证书的需求情况模拟器调试不需要 真机调试 描述文件(Provisioning Profiles) 开发者证书(ios_development.cer) 打包和发布 描述文件(Provisioning Profiles) 可用于发布的开发者证书(ios_distribution.cer) 消息推送后端服务 apns 证书 开发中常见的证书及相关文件介绍CSR(certificate request) 文件用于换取证书的公钥文件, 实际是在本地基于 RSA 加密得到配对的密钥, 私钥存于 Keychain Access 用于签名, 公钥作为换取证书的凭证 生成方法 OSX 系统自带的 Keychain Access 选择 “Request a Certificate From a Certificate Authority…” 输入 email 等信息后保存为 .certSigningRequest 文件 命令行下使用 openssl 生成 12$ openssl genrsa -out private.key 2048$ openssl req -new -sha256 -key private.key -out my.certSigningRequest 开发者证书由 apple 官方颁发, 用来证明开发者资格的证书文件, 分开发(ios_development.cer)和发布(ios_distribution.cer)两种 cer 证书跟开发机(私钥)绑定只能在拥有私钥的机器上使用, 如果要迁移机器需要导出为 p12 文件 生成方法在 开发者中心 “certificates” 面板中添加 certificate 并上传刚刚生成的 CSR 文件, 获取 ios_development.cer apns(Apple Push Notification Service) 证书用于服务端消息推送, 类似 ssl 证书使用, 和 App 端的开发打包没有关系 生成方法在 开发者中心 “Identifiers” 面板中添加 App ID 并上传刚刚生成的 CSR 文件, 获取 aps_production.cer p12(Personal Information Exchange) 证书p12 证书实际是包含了 cer 证书及私钥信息, 可以分发给团队成员 生成方法在 Keychain Access 中找到已经导入的 cer 证书, 点右键导出为 p12 格式 描述文件(Provisioning Profiles)包含 certificate appID devices id 的文件用于在 xcode 调试打包时提供授权的配置信息 生成方法 在 开发者中心 “Provisioning Profiles” 面板中添加 iOS Provisioning Profiles 并上传刚刚生成的 CSR 文件, 获取 .mobileprovision 文件 在 xcode 登录开发者帐号后可以连接开发者中心获取 附录1: 开发准备相关的网址 开发者中心https://developer.apple.com/devcenter/ios/index.action iOS 描述管理(配置证书、描述文件、推送服务)https://developer.apple.com/ios/manage/overview/index.action 切换团队(在 web 界面上死活没有找到)https://developer.apple.com/account/selectTeam.action iOS 上架 Appstorehttp://itunesconnect.apple.com/ 几种开发者帐号区别 详见: https://developer.apple.com/programs/start/ios/ 个人(individual) $99/year 公司(company) $99/year 企业(enterprise) $299/year 大学(University) free 关键区别 个人帐号可以真机调试, 发布 appstore, 每年 最多为 100台设备分发 公司帐号和个人帐号类似, 只有这两种帐号可以发布 appstore, 主要特权是可以添加多个开发者子账号, 但只允许主账号提交, 发布等操作, 在协同开发时比较灵活, 可以各自管理授权设备等 企业帐号无法用于 appstore 发布, 但可以不通过 appstore 发布任意 iphone 都可以安装的应用 大学帐号不能发布 appstore, 主要拥有真机调试的权限 真机调试流程基本概念真机调试指 mac 连上 iphone, xcode 可以直接以这台 iphone 设备为 build target, 能在 iphone 里执行编译结果 条件和流程分为拥有独立开发者帐号(也包括公司帐号或企业帐号成员)和共享开发者帐号两种情况 拥有独立开发者帐号 在 provisioning portal 新建应用, 配置授权设备等 开发机上导入证书 在 xcode 上登录开发者帐号, 不需要准备描述文件, xcode 会自动生成(如果是公司帐号可以自动生成 iOS Team Provisioning Profile) 共享开发者帐号如果无法在 xcode 登录一个开发者帐号, 也可以通过他人对你手机和应用 id 的授权, 得到 .mobileprovision 描述文件再导入其含私钥的证书(p12) 即可, 具体步骤如下: 获得手机的 udid (可以连上 mac, 在 itunes 中查看) 告知对方 udid (用以设备授权) 和 应用 id 得到对方生成的证书和描述文件后, 先导入 p12 证书, 再双击 mobileprovision 文件 连接手机, 在 xcode 中选择 build target 为已连接的手机 对刚入门的个人开发者而言, 可以在淘宝搜 iOS真机调试 花几元购买一份授权, 包含(p12 证书 和 .mobileprovision 描述文件) 内测发布流程基本概念当 App 开发进行到一定程度, 需要更多的人参与测试, 需要谋求一种方式方便应用能安装进更多的设备中 实现条件进行内测发布主要的关键点是: 是如何将应用打包为 .ipa xcode6 以后, 个人/公司帐号无法对应用打包为 .ipa, 要么用 xcode5 打包要么拥有企业帐号级别的授权 设备需不需要授权 个人/公司帐号权限只有在 TestFlight / 越狱渠道下完成不授权安装; 企业帐号授权可以在 ad-hoc / in-house 渠道下分发, 完成不授权设备安装 几种常见的分发途径 ad-hoc 打包时必须在登录企业帐号(或其成员)并已导入证书和描述文件的情况下, 任何用户(未授权)都可以在手机上用浏览器访问一个 url(例: itms-services://?action=download-manifest&amp;url=https://example.com/manifest.plist) 完成安装 最大的问题是安装量有 100 的上限, 无法作为一个量很大的分发渠道 in-house 针对企业内部用户进行分发, 相比 ad-hoc 无安装量上限 iOS 8.1.3 开始不能企业证书 Iresign 方式重新签名的应用无法安装https://support.apple.com/en-us/HT204245 TestFlight 仅支持 iOS8.0 以上, 不需要对设备 udid 进行授权, 适合个人 / 公司开发者, 在应用发布前可以开启 TestFlight Beta 测试并添加测试者的 iTunes Connect 帐号, 需要待测用户拥有 iTunes Connect 帐号并在设备安装 TestFlight 客户端 这种方式非常便于推送应用更新和收集测试信息 导出 ipa 包, 越狱安装 如果测试设备都越狱了, 这种方式非常灵活简单, 只有能导出 ipa 包就能通过 itools 等第三方工具安装 附录2: 常见分发渠道及工具地址 fir-第三方应用托管平台http://fir.im/ TestFlighthttps://developer.apple.com/testflight/ Agile-百度内部 ios 分发测试平台http://agile.baidu.com fir-分发相关工具http://fir.im/dev/tools itoolshttp://www.itools.cn/ Appstore 上架流程@TODO 附录3: App store最新审核标准(2015.3) App store最新审核标准(2015.3) 中文翻译 App store最新审核标准(2015.3) 英文原版]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp使用教程]]></title>
    <url>%2F2016%2F05%2F09%2Fokhttphelp%2F</url>
    <content type="text"><![CDATA[这是一个针对技术开发者的一个应用，你可以在掘金上获取最新最优质的技术干货，不仅仅是Android知识、前端、后端以至于产品和设计都有涉猎，想成为全栈工程师的朋友不要错过！ 入门Android系统提供了两种HTTP通信类，HttpURLConnection和HttpClient。关于HttpURLConnection和HttpClient的选择&gt;&gt;官方博客尽管Google在大部分安卓版本中推荐使用HttpURLConnection，但是这个类相比HttpClient实在是太难用，太弱爆了。OkHttp是一个相对成熟的解决方案，据说Android4.4的源码中可以看到HttpURLConnection已经替换成OkHttp实现了。所以我们更有理由相信OkHttp的强大。 OkHttp 处理了很多网络疑难杂症：会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。 使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果你用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。 注：在国内使用OkHttp会因为这个问题导致部分酷派手机用户无法联网，所以对于大众app来说，需要等待这个bug修复后再使用。或者尝试使用OkHttp的老版本。截止到目前，OkHttp一直没有修复，并把修复计划延迟到了OkHttp2.3中。不是所有设备都能重现，仅少量设备会出现这个问题。（如果问题这么明显，OkHttp早就修复了） 官方资料官方介绍github源码 使用范围OkHttp支持Android 2.3及其以上版本。对于Java, JDK1.7以上。 jar包准备官方介绍页面有链接位置。这里把下载链接也写在下面。OkHttpOkio 基本使用HTTP GET 12345678OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException &#123; Request request = new Request.Builder().url(url).build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; Request是OkHttp中访问的请求，Builder是辅助类。Response即OkHttp中的响应。Response类： 123public boolean isSuccessful()Returns true if the code is in [200..300), which means the request was successfully received, understood, and accepted. response.body()返回ResponseBody类 1234public final String string() throws IOExceptionReturns the response as a string decoded with the charset of the Content-Type header. If that header is either absent or lacks a charset, this will attempt to decode the response body as UTF-8.Throws:IOException 当然也能获取到流的形式： 1public final InputStream byteStream() HTTP POSTPOST提交Json数据 123456789101112131415public static final MediaType JSON = MediaType.parse(&quot;application/json; charset=utf-8&quot;);OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody body = RequestBody.create(JSON, json); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); f (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; 使用Request的post方法来提交请求体RequestBody POST提交键值对很多时候我们会需要通过POST方式把键值对数据传送到服务器。 OkHttp提供了很方便的方式来做这件事情。 123456789101112131415161718192021OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException &#123; RequestBody formBody = new FormEncodingBuilder() .add(&quot;platform&quot;, &quot;android&quot;) .add(&quot;name&quot;, &quot;bug&quot;) .add(&quot;subject&quot;, &quot;XXXXXXXXXXXXXXX&quot;) .build(); Request request = new Request.Builder() .url(url) .post(body) .build(); Response response = client.newCall(request).execute(); if (response.isSuccessful()) &#123; return response.body().string(); &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125;&#125; 总结通过上面的例子我们可以发现，OkHttp在很多时候使用都是很方便的，而且很多代码也有重复，因此特地整理了下面的工具类。注意： OkHttp官方文档并不建议我们创建多个OkHttpClient，因此全局使用一个。 如果有需要，可以使用clone方法，再进行自定义。这点在后面的高级教程里会提到。 enqueue为OkHttp提供的异步方法，入门教程中并没有提到，后面的高级教程里会有解释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.io.IOException;import java.util.List;import java.util.concurrent.TimeUnit;import org.apache.http.client.utils.URLEncodedUtils;import org.apache.http.message.BasicNameValuePair;import cn.wiz.sdk.constant.WizConstant;import com.squareup.okhttp.Callback;import com.squareup.okhttp.OkHttpClient;import com.squareup.okhttp.Request;import com.squareup.okhttp.Response; public class OkHttpUtil &#123; private static final OkHttpClient mOkHttpClient = new OkHttpClient(); static&#123; mOkHttpClient.setConnectTimeout(30, TimeUnit.SECONDS); &#125; /** * 该不会开启异步线程。 * @param request * @return * @throws IOException */ public static Response execute(Request request) throws IOException&#123; return mOkHttpClient.newCall(request).execute(); &#125; /** * 开启异步线程访问网络 * @param request * @param responseCallback */ public static void enqueue(Request request, Callback responseCallback)&#123; mOkHttpClient.newCall(request).enqueue(responseCallback); &#125; /** * 开启异步线程访问网络, 且不在意返回结果（实现空callback） * @param request */ public static void enqueue(Request request)&#123; mOkHttpClient.newCall(request).enqueue(new Callback() &#123; @Override public void onResponse(Response arg0) throws IOException &#123; &#125; @Override public void onFailure(Request arg0, IOException arg1) &#123; &#125; &#125;); &#125; public static String getStringFromServer(String url) throws IOException&#123; Request request = new Request.Builder().url(url).build(); Response response = execute(request); if (response.isSuccessful()) &#123; String responseUrl = response.body().string(); return responseUrl; &#125; else &#123; throw new IOException(&quot;Unexpected code &quot; + response); &#125; &#125; private static final String CHARSET_NAME = &quot;UTF-8&quot;; /** * 这里使用了HttpClinet的API。只是为了方便 * @param params * @return */ public static String formatParams(List&lt;BasicNameValuePair&gt; params)&#123; return URLEncodedUtils.format(params, CHARSET_NAME); &#125; /** * 为HttpGet 的 url 方便的添加多个name value 参数。 * @param url * @param params * @return */ public static String attachHttpGetParams(String url, List&lt;BasicNameValuePair&gt; params)&#123; return url + &quot;?&quot; + formatParams(params); &#125; /** * 为HttpGet 的 url 方便的添加1个name value 参数。 * @param url * @param name * @param value * @return */ public static String attachHttpGetParam(String url, String name, String value)&#123; return url + &quot;?&quot; + name + &quot;=&quot; + value; &#125;&#125; 高级高级属性其实用的不多，这里主要是对OkHttp github官方教程进行了翻译。 同步get下载一个文件，打印他的响应头，以string形式打印响应体。响应体的 string() 方法对于小文档来说十分方便、高效。但是如果响应体太大（超过1MB），应避免适应 string()方法 ，因为他会将把整个文档加载到内存中。对于超过1MB的响应body，应使用流的方式来处理body。 1234567891011121314151617private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); &#125; System.out.println(response.body().string());&#125; 异步get在一个工作线程中下载文件，当响应可读时回调Callback接口。读取响应时会阻塞当前线程。OkHttp现阶段不提供异步api来接收响应体。 123456789101112131415161718192021222324private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Request request, Throwable throwable) &#123; throwable.printStackTrace(); &#125; @Override public void onResponse(Response response) throws IOException &#123; if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Headers responseHeaders = response.headers(); for (int i = 0; i &lt; responseHeaders.size(); i++) &#123; System.out.println(responseHeaders.name(i) + &quot;: &quot; + responseHeaders.value(i)); &#125; System.out.println(response.body().string()); &#125; &#125;);&#125; 提取响应头典型的HTTP头 像是一个 Map&lt;String, String&gt; :每个字段都有一个或没有值。但是一些头允许多个值，像Guava的Multimap。例如：HTTP响应里面提供的Vary响应头，就是多值的。OkHttp的api试图让这些情况都适用。当写请求头的时候，使用header(name, value)可以设置唯一的name、value。如果已经有值，旧的将被移除，然后添加新的。使用addHeader(name, value)可以添加多值（添加，不移除已有的）。当读取响应头时，使用header(name)返回最后出现的name、value。通常情况这也是唯一的name、value。如果没有值，那么header(name)将返回null。如果想读取字段对应的所有值，使用headers(name)会返回一个list。为了获取所有的Header，Headers类支持按index访问。 1234567891011121314151617private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;) .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;) .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;) .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;)); System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;)); System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));&#125; Post方式提交String使用HTTP POST提交请求到服务。这个例子提交了一个markdown文档到web服务，以HTML方式渲染markdown。因为整个请求体都在内存中，因此避免使用此api提交大文档（大于1MB）。 123456789101112131415161718192021222324public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; String postBody = &quot;&quot; + &quot;Releases\n&quot; + &quot;--------\n&quot; + &quot;\n&quot; + &quot; * _1.0_ May 6, 2013\n&quot; + &quot; * _1.1_ June 15, 2013\n&quot; + &quot; * _1.2_ August 11, 2013\n&quot;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交流以流的方式POST提交请求体。请求体的内容由流写入产生。这个例子是流直接写入Okio的BufferedSink。你的程序可能会使用OutputStream，你可以使用BufferedSink.outputStream()来获取。 1234567891011121314151617181920212223242526272829303132333435363738public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody requestBody = new RequestBody() &#123; @Override public MediaType contentType() &#123; return MEDIA_TYPE_MARKDOWN; &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; sink.writeUtf8(&quot;Numbers\n&quot;); sink.writeUtf8(&quot;-------\n&quot;); for (int i = 2; i &lt;= 997; i++) &#123; sink.writeUtf8(String.format(&quot; * %s = %s\n&quot;, i, factor(i))); &#125; &#125; private String factor(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; int x = n / i; if (x * i == n) return factor(x) + &quot; × &quot; + i; &#125; return Integer.toString(n); &#125; &#125;; Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交文件以文件作为请求体是十分简单的。 123456789101112131415161718public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType.parse(&quot;text/x-markdown; charset=utf-8&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; File file = new File(&quot;README.md&quot;); Request request = new Request.Builder() .url(&quot;https://api.github.com/markdown/raw&quot;) .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file)) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交表单使用FormEncodingBuilder来构建和HTML标签相同效果的请求体。键值对将使用一种HTML兼容形式的URL编码来进行编码。 12345678910111213141516private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; RequestBody formBody = new FormEncodingBuilder() .add(&quot;search&quot;, &quot;Jurassic Park&quot;) .build(); Request request = new Request.Builder() .url(&quot;https://en.wikipedia.org/w/index.php&quot;) .post(formBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; Post方式提交分块请求MultipartBuilder可以构建复杂的请求体，与HTML文件上传形式兼容。多块请求体中每块请求都是一个请求体，可以定义自己的请求头。这些请求头可以用来描述这块请求，例如他的Content-Disposition。如果Content-Length和Content-Type可用的话，他们会被自动添加到请求头中。 12345678910111213141516171819202122232425262728private static final String IMGUR_CLIENT_ID = &quot;...&quot;;private static final MediaType MEDIA_TYPE_PNG = MediaType.parse(&quot;image/png&quot;); private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;title\&quot;&quot;), RequestBody.create(null, &quot;Square Logo&quot;)) .addPart( Headers.of(&quot;Content-Disposition&quot;, &quot;form-data; name=\&quot;image\&quot;&quot;), RequestBody.create(MEDIA_TYPE_PNG, new File(&quot;website/static/logo-square.png&quot;))) .build(); Request request = new Request.Builder() .header(&quot;Authorization&quot;, &quot;Client-ID &quot; + IMGUR_CLIENT_ID) .url(&quot;https://api.imgur.com/3/image&quot;) .post(requestBody) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; 使用Gson来解析JSON响应Gson是一个在JSON和Java对象之间转换非常方便的api。这里我们用Gson来解析Github API的JSON响应。注意：ResponseBody.charStream()使用响应头Content-Type指定的字符集来解析响应体。默认是UTF-8。 123456789101112131415161718192021222324private final OkHttpClient client = new OkHttpClient();private final Gson gson = new Gson(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;https://api.github.com/gists/c2a7c39532239ff261be&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); Gist gist = gson.fromJson(response.body().charStream(), Gist.class); for (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123; System.out.println(entry.getKey()); System.out.println(entry.getValue().content); &#125;&#125; static class Gist &#123; Map&lt;String, GistFile&gt; files;&#125; static class GistFile &#123; String content;&#125; 响应缓存为了缓存响应，你需要一个你可以读写的缓存目录，和缓存大小的限制。这个缓存目录应该是私有的，不信任的程序应不能读取缓存内容。一个缓存目录同时拥有多个缓存访问是错误的。大多数程序只需要调用一次new OkHttp()，在第一次调用时配置好缓存，然后其他地方只需要调用这个实例就可以了。否则两个缓存示例互相干扰，破坏响应缓存，而且有可能会导致程序崩溃。响应缓存使用HTTP头作为配置。你可以在请求头中添加Cache-Control: max-stale=3600 ,OkHttp缓存会支持。你的服务通过响应头确定响应缓存多长时间，例如使用Cache-Control: max-age=9600。 123456789101112131415161718192021222324252627282930313233private final OkHttpClient client; public CacheResponse(File cacheDirectory) throws Exception &#123; int cacheSize = 10 * 1024 * 1024; // 10 MiB Cache cache = new Cache(cacheDirectory, cacheSize); client = new OkHttpClient(); client.setCache(cache);&#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://publicobject.com/helloworld.txt&quot;) .build(); Response response1 = client.newCall(request).execute(); if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1); String response1Body = response1.body().string(); System.out.println(&quot;Response 1 response: &quot; + response1); System.out.println(&quot;Response 1 cache response: &quot; + response1.cacheResponse()); System.out.println(&quot;Response 1 network response: &quot; + response1.networkResponse()); Response response2 = client.newCall(request).execute(); if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2); String response2Body = response2.body().string(); System.out.println(&quot;Response 2 response: &quot; + response2); System.out.println(&quot;Response 2 cache response: &quot; + response2.cacheResponse()); System.out.println(&quot;Response 2 network response: &quot; + response2.networkResponse()); System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));&#125; 扩展在这一节还提到了下面一句：There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. 我不是很懂cache，平时用到的也不多，所以把Google在Android Developers一段相关的解析放到这里吧。 Force a Network ResponseIn some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the no-cache directive: connection.addRequestProperty(“Cache-Control”, “no-cache”); If it is only necessary to force a cached response to be validated by the server, use the more efficient max-age=0 instead: connection.addRequestProperty(“Cache-Control”, “max-age=0”); ##Force a Cache ResponseSometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the only-if-cached directive: 12345678try &#123; connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;); InputStream cached = connection.getInputStream(); // the resource was cached! show it catch (FileNotFoundException e) &#123; // the resource was not cached &#125;&#125; This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the max-stale directive with the maximum staleness in seconds: 1int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks staleconnection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale); 以上信息来自：HttpResponseCache - Android SDK | Android Developers 取消一个Call使用Call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException。当call没有必要的时候，使用这个api可以节约网络资源。例如当用户离开一个应用时。不管同步还是异步的call都可以取消。你可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。之后你就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call。 123456789101112131415161718192021222324252627282930private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); final long startNanos = System.nanoTime(); final Call call = client.newCall(request); // Schedule a job to cancel the call in 1 second. executor.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.printf(&quot;%.2f Canceling call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); call.cancel(); System.out.printf(&quot;%.2f Canceled call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); &#125; &#125;, 1, TimeUnit.SECONDS); try &#123; System.out.printf(&quot;%.2f Executing call.%n&quot;, (System.nanoTime() - startNanos) / 1e9f); Response response = call.execute(); System.out.printf(&quot;%.2f Call was expected to fail, but completed: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, response); &#125; catch (IOException e) &#123; System.out.printf(&quot;%.2f Call failed as expected: %s%n&quot;, (System.nanoTime() - startNanos) / 1e9f, e); &#125;&#125; 超时没有响应时使用超时结束call。没有响应的原因可能是客户点链接问题、服务器可用性问题或者这之间的其他东西。OkHttp支持连接，读取和写入超时 1234567891011121314151617private final OkHttpClient client; public ConfigureTimeouts() throws Exception &#123; client = new OkHttpClient(); client.setConnectTimeout(10, TimeUnit.SECONDS); client.setWriteTimeout(10, TimeUnit.SECONDS); client.setReadTimeout(30, TimeUnit.SECONDS);&#125; public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/2&quot;) // This URL is served with a 2 second delay. .build(); Response response = client.newCall(request).execute(); System.out.println(&quot;Response completed: &quot; + response);&#125; 每个call的配置使用OkHttpClient，所有的HTTP Client配置包括代理设置、超时设置、缓存设置。当你需要为单个call改变配置的时候，clone 一个 OkHttpClient。这个api将会返回一个浅拷贝（shallow copy），你可以用来单独自定义。下面的例子中，我们让一个请求是500ms的超时、另一个是3000ms的超时。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; Request request = new Request.Builder() .url(&quot;http://httpbin.org/delay/1&quot;) // This URL is served with a 1 second delay. .build(); try &#123; Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(500, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 1 succeeded: &quot; + response); &#125; catch (IOException e) &#123; System.out.println(&quot;Response 1 failed: &quot; + e); &#125; try &#123; Response response = client.clone() // Clone to make a customized OkHttp for this request. .setReadTimeout(3000, TimeUnit.MILLISECONDS) .newCall(request) .execute(); System.out.println(&quot;Response 2 succeeded: &quot; + response); &#125; catch (IOException e) &#123; System.out.println(&quot;Response 2 failed: &quot; + e); &#125;&#125; 处理验证这部分和HTTP AUTH有关。相关资料：HTTP AUTH 那些事 - 王绍全的博客 - 博客频道 - CSDN.NET OkHttp会自动重试未验证的请求。当响应是401 Not Authorized时，Authenticator会被要求提供证书。Authenticator的实现中需要建立一个新的包含证书的请求。如果没有证书可用，返回null来跳过尝试。 123456public List&lt;Challenge&gt; challenges()Returns the authorization challenges appropriate for this response&apos;s code. If the response code is 401 unauthorized, this returns the &quot;WWW-Authenticate&quot; challenges.If the response code is 407 proxy unauthorized, this returns the &quot;Proxy-Authenticate&quot; challenges.Otherwise this returns an empty list of challenges. 当需要实现一个Basic challenge， 使用Credentials.basic(username, password)来编码请求头。 123456789101112131415161718192021222324252627private final OkHttpClient client = new OkHttpClient(); public void run() throws Exception &#123; client.setAuthenticator(new Authenticator() &#123; @Override public Request authenticate(Proxy proxy, Response response) &#123; System.out.println(&quot;Authenticating for response: &quot; + response); System.out.println(&quot;Challenges: &quot; + response.challenges()); String credential = Credentials.basic(&quot;jesse&quot;, &quot;password1&quot;); return response.request().newBuilder() .header(&quot;Authorization&quot;, credential) .build(); &#125; @Override public Request authenticateProxy(Proxy proxy, Response response) &#123; return null; // Null indicates no attempt to authenticate. &#125; &#125;); Request request = new Request.Builder() .url(&quot;http://publicobject.com/secrets/hellosecret.txt&quot;) .build(); Response response = client.newCall(request).execute(); if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response); System.out.println(response.body().string());&#125; 转自 OkHttp使用介绍 同时整合了 OkHttp使用进阶 这篇文章以及其中的评论。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>okhttp</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你几招，蚊子一个夏天不敢进你的房间！！]]></title>
    <url>%2F2016%2F05%2F09%2Fgowaywenzi%2F</url>
    <content type="text"><![CDATA[教你几招，蚊子一个夏天不敢进你的房间！！ 前言“多蚊季节来了，谁都不叮偏偏就来叮你？嗡嗡吵得睡不着？怕宝宝被感染？下面教教大家一些驱蚊小窍门！！ 方法一： 用空酒瓶装上糖水或啤酒放在阴暗处，蚊子闻到甜味就会往瓶子里钻，会被啤酒或糖水黏住致死。 方法二：沸过的醋用碟装，放到房间里不用关门，整夜都不会被蚊子打扰。 ##方法三: 避免在花纹蚊出没的时段（上午7-9时，下午4时到黄昏）在树荫、树丛、凉亭等阴暗处逗留。 方法四: 在室内点燃柑橘皮，既能驱蚊又能消除屋内异味。 方法五： 关上门窗，窗前放一个盆子，盆子加混合洗衣粉的水，第二天水盆中就会有死去的蚊子。 方法六： 房间里拜访驱蚊草。 方法七： 到登隔热流行区旅行，应穿上长袖衣服及长裤，并在外露皮肤及衣服上涂蚊虫趋避药物。 方法八： 3到5天刷洗水缸、换水一次，并翻盆倒罐、清除花盆、废气罐子等积水。 方法九： 房间里放几盒开着的风油精。 11种防蚊子奇招妙法 1、维生素B泡水擦身，会让蚊子不敢近身，并且这种水溶性维生素没有副作用。 2、在室内点燃干桔皮，可取代蚊香，既能驱蚊，又可消除屋内异味。 3、尽量穿袜子。许多人喜欢夏天光脚穿鞋，殊不知穿袜子后，蚊子感觉人的皮肤湿度降低、皮表挥发物减少，会减少叮咬。 4、在使用驱蚊药时，1个品牌连续使用2个月后，换一种药物驱蚊，效果更好。 5、关上门窗，在窗前放置一盆混合洗衣粉的水，越日水盆中就会有一些死去的蚊子。每天持续使用，可以不用再喷杀虫剂了。 6、在房间里放上几盒开盖的风油精、清冷油，或在墙上涂点薄荷。 7、在身上或寝具上洒些香水。 8、将樟脑丸磨碎、撒在屋内墙角。 9、在室内的花盆里栽一两株番茄，番茄枝叶发出的气味会把蚊子驱除。 10、在灯下挂一把香葱，或用纱袋装几根葱段，各种小虫都不会飞来。 11、用橘红色玻璃纸或绸布套在灯泡上，蚊子最怕橘红色光。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>驱蚊  life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工（bandwagon）搭建VPN]]></title>
    <url>%2F2016%2F05%2F09%2Fbuildvpn%2F</url>
    <content type="text"><![CDATA[最近注册了一个搬瓦工，开始只为了翻墙，方便查资料和上网。后来发现了搬瓦工功能还比较强大，一年19美元10G流量（搬瓦工：https://bandwagonhost.com/），我目前配合了shadowsocks使用，ios用的surge，by the way，surge相当的强大，搬瓦工还可以搭件个人网站。关于搬瓦工的注册，在这里就不再阐述了，很简单，百度google都有，好了，下面开工，搭建VPN吧。 最近注册了一个搬瓦工，开始只为了翻墙，方便查资料和上网。后来发现了搬瓦工功能还比较强大，一年19美元10G流量（搬瓦工：https://bandwagonhost.com/），我目前配合了shadowsocks使用，ios用的surge，by the way，surge相当的强大，搬瓦工还可以搭件个人网站。关于搬瓦工的注册，在这里就不再阐述了，很简单，百度google都有，好了，下面开工，搭建VPN吧。 安装服务（VPN-PPTP）运行如下命令 12345678910wget http://www.5yun.org/Soft/linux/Openvz-vpn/openvps_vpn_centos-5-6.shchmod a+x openvps_vpn_centos-5-6.sh bash openvps_vpn_centos-5-6.sh#如果以上地址不可用，可尝试以下命令，#这个脚本只提供三个选项，一般选择1就可以自动完成全部过程#去掉注释符号#wget http://www.hi-vps.com/shell/vpn_centos6.sh#chmod a+x vpn_centos6.sh#bash vpn_centos6.sh 结果如下： 上边第一步是获取一个自动脚本，第二步是给它运行权限，第三步是运行。有时候会遇到第一步无法成功，这时候在本地先下载这个文件，再使用Putty或者SSH客户端上传到VPS也是可以的。执行以上命令后将会返回一个选择系统版本的提示信息，因为之前我们选择的是centos6 ，因此选择第2项，输入2，回车： 1234567[root@localhost ~]# bash openvps_vpn_centos-5-6.shplease select your operation systemwhich do you want to?input the number.1. my system is centos5 32bit(only support 32bit)2. my system is centos6 32bit or 64bit(they are support)3. repaire VPN service4. add VPN user 执行命令后将自动安装，成功后返回一下信息：VPN service is installed, your VPN username is vpn_name,VPN password is 这句话提示成功创建了一个名为vpn_name的账户，密码为 。 执行命令后报404错误，或者提示文件或目录不存在，是因为没能成功下载安装包。这里提供手动下载安装包的方法如果是centos6，执行以下命令： 1234wget http://linux.dell.com/dkms/permalink/dkms-2.0.17.5-1.noarch.rpmwget https://acelnmp.googlecode.com/files/kernel_ppp_mppe-1.0.2-3dkms.noarch.rpmwget https://qiaodahai.googlecode.com/files/pptpd-1.3.4-2.el6.i686.rpmwget https://logdns.googlecode.com/files/ppp-2.4.5-17.0.rhel6.i686.rpm 如果是 centos5，则执行以下命令： 1234wget http://linux.dell.com/dkms/permalink/dkms-2.0.17.5-1.noarch.rpmwget https://acelnmp.googlecode.com/files/kernel_ppp_mppe-1.0.2-3dkms.noarch.rpmwget https://acelnmp.googlecode.com/files/pptpd-1.3.4-1.rhel5.1.i386.rpmwget https://fastlnmp.googlecode.com/files/ppp-2.4.4-9.0.rhel5.i386.rpm 添加自己的VPN账号如何添加自己的vpn账户名？ 比如我想用 anonymous 这个帐号，密码设置为 abc@123 (注意，危险！仅作为演示用，千万别设置这样的密码！) 执行下面这句代码来添加vpn账户： 1bash openvps_vpn_centos-5-6.sh 返回的信息选项中，选择第4项：4.add VPN user1234567[root@localhost ~]# bash openvps_vpn_centos-5-6.shplease select your operation systemwhich do you want to?input the number.1. my system is centos5 32bit(only support 32bit)2. my system is centos6 32bit or 64bit(they are support)3. repaire VPN service4. add VPN user 根据提示输入用户名，如 anonymous，再输入密码 即可完成vpn的架设了。使用时，在本地新建VPN连接，地址和端口填写VPS的地址和端口，用户名密码填写自己设置的VPN的用户名和密码，然后连接，就可以了。如有疑问，请留言讨论。 在Terminal里面添加VPN帐号： 1vi /etc/ppp/chap-secrets 键盘选择插入键：Insert 进行编辑， 使用键盘上下左右将光标插入另一行按照以下格式输入vpn pptpd Xk0jk78f 注释：vpn 用户名Xk0jk78f 密码pptpd 和 不变，字符中间必须用一个空格隔开。数字123，选用键盘字母键上方，不要用数字小键盘如上输入完成，按下键盘左上方ESC键盘，英文状态下输入红色字体 ：wq 即保存好了。现在只要电脑设置好，就可以自由的畅享网络了。 referenceCentos6.X vpn pptp 搭建方法搬瓦工vps vpn架设 http://www.phpsong.com/1126.html http://www.figotan.org/2016/05/04/cook-your-own-vpn/?ref=myread Appendix最近妖风太盛，所以如果自己有能力的童鞋，请移步Github的这个项目MPTUN自己研究怎么搭建VPN吧，当然VPS还是必要的。单单这篇文章访问量超高，让我陷入了沉思……补充一点东西：有能力的同学，可以研究一下ssh的端口流量转发，浏览器或网络连接的socks5代理，基本上可以解决VPN被封杀时候的情况。ssh的协议特征很明显，我觉得迟早还是会被解决，同学们如果不嫌麻烦，VPN还有几种通信协议，可以研究一下。希望不会被查水表吧，我也不喜欢喝茶。 如果只需要浏览器翻墙，而不需要全局翻墙，那么SSH代理配合SwitchyOmega插件使用chrome浏览器就可以做到。最近发现一个方便的工具，Chrome插件Secure Shell，在浏览器完成SSH代理。]]></content>
      <categories>
        <category>vpn</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android孤儿进程防止清理]]></title>
    <url>%2F2016%2F05%2F09%2Fdeamon%2F</url>
    <content type="text"><![CDATA[孤儿进程:因为父进程先退出而导致一个子进程被init进程收养的进程为孤儿进程 孤儿进程:因为父进程先退出而导致一个子进程被init进程收养的进程为孤儿进程。因此，可以通过创建孤儿进程，改变native进程的父进程，达到防止系统清理。 关键代码实现: 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main()&#123; pid_t child_pid; child_pid=fork(); if(child_pid&lt;0) &#123; perror(&quot;fork error&quot;); exit(EXIT_FAILURE); &#125; if(child_pid==0)//子进程处理 事务 &#123; while(1) &#123; printf(&quot;hello world\n&quot;); sleep(1); &#125; return 0; &#125;else &#123; printf(&quot;father bye byte\n&quot;); exit(EXIT_SUCCESS); &#125;&#125;]]></content>
      <categories>
        <category>Service</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[大家好，我是XXX。欢迎来到我的个人技术博客。 这里用markdown写下你的简介，就跟平时写md一样就可以了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2Freading%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
